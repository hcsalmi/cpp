
/*
void    PmergeMe::makePairs(int n)
{
    if (n > 1)
    {
        n = n / 2;
        std::cout << "n in if statement: " << n << std::endl;
        makePairs(n);
    }
    if (n == 2)
    {
        std::pair<int, int> myPair = std::make_pair(this->_vectorChainA[n], y);
        this->_vectorChainB.push():
        this->_vectorChainA.pop();
    }
    if (n == 1)
        return ;
    std::cout << n << std::endl;

}
*/





/*
 for (size_t i = 0; i + 1 < vec.size(); i += 2) {
        pairedVec.push_back(std::make_pair(vec[i], vec[i + 1]));
    }

    // If the vector has odd length, handle the last unpaired element
    if (vec.size() % 2 == 1) {
        pairedVec.push_back(std::make_pair(vec.back(), -1)); // For FJ sort, we need a placeholder for the unpaired element
    }

*/
/*
if (n > 1) {
        n = n / 2;
        std::cout << "n in if statement: " << n << std::endl;
        makePairs(n);
    }
    if (n == 2) {
        // Assuming this->_vectorChainA is a vector<int> containing elements to pair
        // Assuming this->_vectorChainB is a vector<std::pair<int, int>> to store pairs
        if (this->_vectorChainA.size() >= 2)
        {
            int x = this->_vectorChainA.front(); // Retrieve the first element
            this->_vectorChainA.erase(this->_vectorChainA.begin()); // Remove the first element
            int y = this->_vectorChainA.front(); // Retrieve the new first element
            this->_vectorChainA.erase(this->_vectorChainA.begin()); // Remove the new first element
            std::pair<int, int> myPair = std::make_pair(x, y);
            this->_vectorChainB.push_back(myPair); // Push the pair into chain B
        }
    }
    if (n == 1) {
        // Handle the case where there's one element left in chain A (if the number of elements is odd)
        if (!this->_vectorChainA.empty()) {
            // Handle the last unpaired element
            int lastElement = this->_vectorChainA.back();
            this->_vectorChainA.pop_back();
            // Handle what to do with the last unpaired element (maybe push it to chain B?)
        }
    }


void	PmergeMe::insertIntoV()
{
    std::vector<unsigned int>::iterator it;
    std::vector<unsigned int>::iterator it2;

    for (it = this->_vectorChainB.begin(); it != this->_vectorChainB.end(); it++)
    {
        unsigned int toInsert = *it;
        std::cout << "Current value toInsert: " << toInsert << std::endl;
        if (toInsert < *(this->_vectorChainA.begin()))
        {
            this->_vectorChainA.insert(this->_vectorChainA.begin(), toInsert);
            this->_vectorChainB.erase(it);
            continue ;
        }
        if (toInsert > *(this->_vectorChainA.end()))
        {
            this->_vectorChainA.insert(this->_vectorChainA.end(), toInsert);
            this->_vectorChainB.erase(it);
            continue ;
        }

        else
        {
            for (it2 = this->_vectorChainA.begin() + 1; it2 != this->_vectorChainA.end(); it2++)
            {
                unsigned int toCompare = *it2;
                std::cout << "Current value toCompare: " << toCompare << std::endl;
                if (toInsert < toCompare && toInsert > (*it2 + 1))
                {
                     this->_vectorChainA.insert(it2, toInsert);
                     std::cout << "Inserted" << toInsert << std::endl;
                     break ;
                }
            }
        }
    }

}
*/





//WORKS

/*
void	PmergeMe::insertIntoV()
{
    unsigned int toInsert;

    for (unsigned int i = 0; i < this->_vectorChainB.size(); i++)
    {
        toInsert = this->_vectorChainB[i];
        unsigned int size = this->_vectorChainA.size();

        if (toInsert <= this->_vectorChainA[0])
        {
            this->_vectorChainA.insert(this->_vectorChainA.begin(), toInsert);
            continue ;
        }
        if (toInsert >= this->_vectorChainA[this->_vectorChainA.size() - 1])
        {
            this->_vectorChainA.insert(this->_vectorChainA.end(), toInsert);
            continue ;
        }
        for (int j = size - 2; j >= 0; j--)
        {
            if (this->_vectorChainA[j] <= toInsert && this->_vectorChainA[j + 1] > toInsert)
            {
                this->_vectorChainA.insert(this->_vectorChainA.begin() + j + 1, toInsert);
                break;
            }
        }
    }
}
*/



/*
void PmergeMe::insertIntoV()
{
    unsigned int toInsert;

    // Get the initial size of chainB
    unsigned int chainBSize = this->_vectorChainB.size();

    // Loop up to the initial size of chainB
    for (unsigned int i = 0; i < chainBSize; i++)
    {
        toInsert = this->_vectorChainB[i];
        unsigned int size = this->_vectorChainA.size();

        // Insertion logic...

        // Erase the inserted element from chainB
        this->_vectorChainB.erase(this->_vectorChainB.begin());

        // Update the size of chainB
        chainBSize = this->_vectorChainB.size();
    }
}
*/
//AND
/*
 unsigned int toInsert;

    // Loop through all elements in chainB
    while (!this->_vectorChainB.empty())
    {
        // Get the element to insert (always the first element of chainB)
        toInsert = this->_vectorChainB[0];
        
        unsigned int size = this->_vectorChainA.size();

        // Insertion logic...

        // Erase the inserted element from chainB
        this->_vectorChainB.erase(this->_vectorChainB.begin());
    }

*/


//rinnakkaiset chainit
void    PmergeMe::sortVector() //vai tarvitaanko vain parien maara?
{
//    std::cout << "Pairs in vectorPaired: " << this->_vectorPaired.size() << std::endl;
    
    //chainB -> ota sisaan ja jarjesta jo parit suuruusjÃ¤rjestykseen? -> vrt. parien arvoja, pienimmat ensin (parin sisalla ja parien valilla)

    //do sort: recursive function where you pair and sort

    //save time in object
}

void    PmergeMe::sortDeque()
{
    //start timer
    //do sort
    //save time in object
}








// https://www.reddit.com/r/algorithms/comments/1bajgye/merge_insertion_ford_johnson/
// https://github.com/decidedlyso/merge-insertion-sort/blob/master/README.md

// https://github.com/orgs/hivehelsinki/followers

// https://stackoverflow.com/questions/27751132/how-does-merge-insertion-sort-work